<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta name="generator" content="HTML::TextToHTML v2.51"/>
</head>
<body>
<p>/**
</p>
<p> \page  common Common Widgets and Attributes
</p>
<p>This chapter describes many of the widgets that are provided
with FLTK and covers how to query and set the standard
attributes.
</p>
<p>\section common_buttons Buttons
</p>
<p>FLTK provides many types of buttons:
</p>
<p>\li Fl_Button - A standard push button.
</p>
<p>\li Fl_Check_Button - A button with a check box.
</p>
<p>\li Fl_Light_Button - A push button with a light.
</p>
<p>\li Fl_Repeat_Button - A push button that repeats when held.
</p>
<p>\li Fl_Return_Button - A push button that is activated by the
</p><p>    \p Enter key.
</p>
<p>\li Fl_Round_Button - A button with a radio circle.
</p>
<p>\image html buttons.png "Figure 3-1: FLTK Button Widgets"
\image latex buttons.png "FLTK Button Widgets" width=10cm
</p>
<p>All of these buttons just need the corresponding
&lt;tt&gt;&lt;FL/Fl_xyz_Button.H&gt;&lt;/tt&gt; header file. The constructor
takes the bounding box of the button and optionally a label
string:
</p>
<p>\code<br/>
Fl_Button *button = new Fl_Button(x, y, width, height, "label");
Fl_Light_Button *lbutton = new Fl_Light_Button(x, y, width, height);
Fl_Round_Button *rbutton = new Fl_Round_Button(x, y, width, height, "label");
\endcode
</p>
<p>Each button has an associated \p type() which allows
it to behave as a push button, toggle button, or radio button:
</p>
<p>\code<br/>
button-&gt;type(FL_NORMAL_BUTTON);<br/>
lbutton-&gt;type(FL_TOGGLE_BUTTON);<br/>
rbutton-&gt;type(FL_RADIO_BUTTON);<br/>
\endcode
</p>
<p>For toggle and radio buttons, the \p value() method returns 
the current button state (0 = off, 1 = on). The \p set() and
\p clear() methods can be used on toggle buttons to turn a 
toggle button on or off, respectively. 
Radio buttons can be turned on with the \p setonly()
method; this will also turn off other radio buttons in the same
group.
</p>
<p>\section common_text Text
</p>
<p>FLTK provides several text widgets for displaying and receiving text:
</p>
<p>\li Fl_Input - A one-line text input field.
</p>
<p>\li Fl_Output - A one-line text output field.
</p>
<p>\li Fl_Multiline_Input - A multi-line text input field.
</p>
<p>\li Fl_Multiline_Output - A multi-line text output field.
</p>
<p>\li Fl_Text_Display - A multi-line text display widget.
</p>
<p>\li Fl_Text_Editor - A multi-line text editing widget.
</p>
<p>\li Fl_Help_View - A HTML text display widget.
</p>
<p>The Fl_Output and Fl_Multiline_Output<br/>
widgets allow the user to copy text from the output field but
not change it.
</p>
<p>The \p value() method is used to get or set the 
string that is displayed:
</p>
<p>\code<br/>
Fl_Input *input = new Fl_Input(x, y, width, height, "label");
input-&gt;value("Now is the time for all good men...");
\endcode
</p>
<p>The string is copied to the widget's own storage when you set
the \p value() of the widget.
</p>
<p>The Fl_Text_Display and Fl_Text_Editor<br/>
widgets use an associated Fl_Text_Buffer class for the
value, instead of a simple string.
</p>
<p>&lt;!-- NEED 4in --&gt;
</p>
<p>\section common_valuators Valuators
</p>
<p>Unlike text widgets, valuators keep track of numbers instead of
strings. FLTK provides the following valuators:
</p>
<p>\li Fl_Counter - A widget with arrow buttons that shows the current value.
</p>
<p>\li Fl_Dial - A round knob.
</p>
<p>\li Fl_Roller - An SGI-like dolly widget.
</p>
<p>\li Fl_Scrollbar - A standard scrollbar widget.
</p>
<p>\li Fl_Slider - A scrollbar with a knob.
</p>
<p>\li Fl_Value_Slider - A slider that shows the current value.
</p>
<p>\image html valuators.png "Figure 3-2: FLTK valuator widgets"
\image latex valuators.png "FLTK valuator widgets" width=10cm
</p>
<p>The \p value() method gets and sets the current value 
of the widget. The \p minimum() and \p maximum()
methods set the range of values that are reported by the
widget.
</p>
<p>&lt;!-- NEED 5in --&gt;
</p>
<p>\section common_groups Groups
</p>
<p>The Fl_Group widget class is used as a general
purpose "container" widget. Besides grouping radio
buttons, the groups are used to encapsulate windows, tabs, and
scrolled windows. The following group classes are available
with FLTK:
</p>
<p>\li Fl_Double_Window - A double-buffered window on the screen.
</p>
<p>\li Fl_Gl_Window - An OpenGL window on the screen.
</p>
<p>\li Fl_Group - The base container class; can be used to group
</p><p>    any widgets together.
</p>
<p>\li Fl_Pack - A collection of widgets that are packed into the group area.
</p>
<p>\li Fl_Scroll - A scrolled window area.
</p>
<p>\li Fl_Tabs - Displays child widgets as tabs.
</p>
<p>\li Fl_Tile - A tiled window area.
</p>
<p>\li Fl_Window - A window on the screen.
</p>
<p>\li Fl_Wizard - Displays one group of widgets at a time.
</p>
<p>\section common_sizeposition Setting the Size and Position of Widgets
</p>
<p>The size and position of widgets is usually set when you create them.
You can access them with the \p x(), \p y(), \p w(), and \p h()
methods.
</p>
<p>You can change the size and position by using the \p position(),
\p resize(), and \p size() methods:
</p>
<p>\code<br/>
button-&gt;position(x, y);<br/>
group-&gt;resize(x, y, width, height);<br/>
window-&gt;size(width, height);<br/>
\endcode
</p>
<p>If you change a widget's size or position after it is
displayed you will have to call \p redraw() on the
widget's parent.
</p>
<p>\section common_colors Colors
</p>
<p>FLTK stores the colors of widgets as an 32-bit unsigned
number that is either an index into a color palette of 256
colors or a 24-bit RGB color. The color palette is \e not
the X or MS Windows colormap, but instead is an internal table with
fixed contents.
</p>
<p>See the<br/>
\ref drawing_colors<br/>
section of<br/>
\ref drawing<br/>
for implementation details.
</p>
<p>There are symbols for naming some of the more common colors:
</p>
<p>\li \p FL_BLACK<br/>
\li \p FL_RED<br/>
\li \p FL_GREEN<br/>
\li \p FL_YELLOW<br/>
\li \p FL_BLUE<br/>
\li \p FL_MAGENTA<br/>
\li \p FL_CYAN<br/>
\li \p FL_WHITE<br/>
\li \p FL_WHITE
</p>
<p>Other symbols are used as the default colors for all FLTK widgets.
</p>
<p>\li \p FL_FOREGROUND_COLOR<br/>
\li \p FL_BACKGROUND_COLOR<br/>
\li \p FL_INACTIVE_COLOR<br/>
\li \p FL_SELECTION_COLOR
</p>
<p>The full list of named color values can be found in
\ref enumerations_colors "FLTK Enumerations".
</p>
<p>A color value can be created from its RGB components by using the
\p %fl_rgb_color() function, and decomposed again with
\p Fl::get_color():
</p>
<p>\code<br/>
Fl_Color c = fl_rgb_color(85, 170, 255);    // RGB to Fl_Color
Fl::get_color(c, r, g, b);                  // Fl_Color to RGB
\endcode
</p>
<p>The widget color is set using the \p color() method:
</p>
<p>\code<br/>
button-&gt;color(FL_RED);                      // set color using named value
\endcode
</p>
<p>Similarly, the label color is set using the \p labelcolor() method:
</p>
<p>\code<br/>
button-&gt;labelcolor(FL_WHITE);<br/>
\endcode
</p>
<p>The Fl_Color encoding maps to a 32-bit unsigned integer representing
RGBI, so it is also possible to specify a color using a hex constant
as a color map index:
</p>
<p>\code<br/>
button-&gt;color(0x000000ff);                  // colormap index #255 (FL_WHITE)
\endcode
</p>
<p>or specify a color using a hex constant for the RGB components:
</p>
<p>\code
</p><pre>
button-&gt;color(0xff000000);                  // RGB: red
button-&gt;color(0x00ff0000);                  // RGB: green
button-&gt;color(0x0000ff00);                  // RGB: blue
button-&gt;color(0xffffff00);                  // RGB: white
</pre>
<p>\endcode
</p>
<p>\note<br/>
If TrueColor is not available, any RGB colors will be set to
the nearest entry in the colormap.
</p>
<p>\section common_boxtypes Box Types
</p>
<p>The type Fl_Boxtype stored and returned in Fl_Widget::box()
is an enumeration defined in Enumerations.H.
</p>
<p>Figure 3-3 shows the standard box types included with FLTK.
</p>
<p>\image html boxtypes.png "Figure 3-3: FLTK box types"
\image latex boxtypes.png "FLTK box types" width=12cm
</p>
<p>\p FL_NO_BOX means nothing is drawn at all, so whatever is
already on the screen remains. The &lt;tt&gt;FL_..._FRAME&lt;/tt&gt; types only
draw their edges, leaving the interior unchanged. The blue color in
Figure 3-3 is the area that is not drawn by the frame types.
</p>
<p>\subsection common_custom_boxtypes Making Your Own Boxtypes
</p>
<p>You can define your own boxtypes by making a small function that draws
the box and adding it to the table of boxtypes.
</p>
<p>\par The Drawing Function
</p>
<p>The drawing function is passed the bounding box and background color
for the widget:
</p>
<p>\code<br/>
void xyz_draw(int x, int y, int w, int h, Fl_Color c) {
...<br/>
}<br/>
\endcode
</p>
<p>&lt;!-- NEED 3in --&gt;
</p>
<p>A simple drawing function might fill a rectangle with the
given color and then draw a black outline:
</p>
<p>\code<br/>
void xyz_draw(int x, int y, int w, int h, Fl_Color c) {
  fl_color(c);<br/>
  fl_rectf(x, y, w, h);<br/>
  fl_color(FL_BLACK);<br/>
  fl_rect(x, y, w, h);<br/>
}<br/>
\endcode
</p>
<p>\anchor common_fl_down<br/>
Fl_Boxtype fl_down(Fl_Boxtype b)
</p>
<p>\par<br/>
fl_down() returns the "pressed" or "down" version of a box.
If no "down" version of a given box exists, the behavior of this function
is undefined and some random box or frame is returned.
See \ref drawing_fl_frame "Drawing Functions" for more details.
</p>
<p>\anchor common_fl_frame<br/>
Fl_Boxtype fl_frame(Fl_Boxtype b)
</p>
<p>\par<br/>
fl_frame() returns the unfilled, frame-only version of a box.
If no frame version of a given box exists, the behavior of this function
is undefined and some random box or frame is returned.
See \ref drawing_fl_frame "Drawing Functions" for more details.
</p>
<p>Fl_Boxtype fl_box(Fl_Boxtype b)
</p>
<p>\par<br/>
fl_box() returns the filled version of a frame.
If no filled version of a given frame exists, the behavior of this function
is undefined and some random box or frame is returned.
See \ref drawing_fl_frame "Drawing Functions" for more details.
</p>
<p>\par Adding Your Box Type
</p>
<p>The Fl::set_boxtype() method adds or replaces the specified box type:
</p>
<p>\code<br/>
#define XYZ_BOX FL_FREE_BOXTYPE
</p>
<p>Fl::set_boxtype(XYZ_BOX, xyz_draw, 1, 1, 2, 2);
\endcode<br/>
The last 4 arguments to Fl::set_boxtype() are the
offsets for the \p x, \p y, \p width, and \p height values that should be
subtracted when drawing the label inside the box.
</p>
<p>A complete box design contains four box types in this order: 
a filled, neutral box (&lt;tt&gt;UP_BOX&lt;/tt&gt;),
a filled, depressed box (&lt;tt&gt;DOWN_BOX&lt;/tt&gt;),
and the same as outlines only (&lt;tt&gt;UP_FRAME&lt;/tt&gt; and &lt;tt&gt;DOWN_FRAME&lt;/tt&gt;).
The function<br/>
\ref common_fl_down "fl_down(Fl_Boxtype)"
expects the neutral design on a boxtype with a numerical 
value evenly dividable by two. <br/>
\ref common_fl_frame "fl_frame(Fl_Boxtype)"
expects the \p UP_BOX design at a value dividable by four.
</p>
<p>\section common_labels Labels and Label Types
</p>
<p>The \p label(), \p align(), \p labelfont(), \p labelsize(),
\p labeltype(), \p image(), and \p deimage() methods control the
labeling of widgets.
</p>
<p>\par label()
</p>
<p>The \p label() method sets the string that is displayed
for the label. Symbols can be included with the label string by
escaping them using the "@" symbol - "@@" displays a single at
sign. Figure 3-4 shows the available symbols.
</p>
<p>\image html symbols.png "Figure 3-4: FLTK label symbols"
\image latex symbols.png "FLTK label symbols" width=10cm
</p>
<p>&lt;!-- NEED 2in --&gt;
</p>
<p>The @ sign may also be followed by the following optional
"formatting" characters, in this order:
</p>
<p>\li '#' forces square scaling, rather than distortion to the widget's shape.
</p>
<p>\li +[1-9] or -[1-9] tweaks the scaling a little bigger or smaller.
</p>
<p>\li '$' flips the symbol horizontally, '\%' flips it vertically.
</p>
<p>\li [0-9] - rotates by a multiple of 45 degrees. '5' and '6' do no rotation
</p><p>    while the others point in the direction of that key on a numeric keypad.
    '0', followed by four more digits rotates the symbol by that amount in
    degrees.
</p>
<p>Thus, to show a very large arrow pointing downward you would use the
label string "@+92-&gt;".
</p>
<p>\par align()
</p>
<p>The \p align() method positions the label. The following
constants are defined and may be OR'd together as needed:
</p>
<p>\li \p FL_ALIGN_CENTER - center the label in the widget.
\li \p FL_ALIGN_TOP - align the label at the top of the widget.
\li \p FL_ALIGN_BOTTOM - align the label at the bottom of the widget.
\li \p FL_ALIGN_LEFT - align the label to the left of the widget.
\li \p FL_ALIGN_RIGHT - align the label to the right of the widget.
\li \p FL_ALIGN_LEFT_TOP - The label appears to the left of the widget, aligned at the top. Outside labels only.
\li \p FL_ALIGN_RIGHT_TOP - The label appears to the right of the widget, aligned at the top. Outside labels only.
\li \p FL_ALIGN_LEFT_BOTTOM - The label appears to the left of the widget, aligned at the bottom. Outside labels only.
\li \p FL_ALIGN_RIGHT_BOTTOM - The label appears to the right of the widget, aligned at the bottom. Outside labels only.
\li \p FL_ALIGN_INSIDE - align the label inside the widget.
\li \p FL_ALIGN_CLIP - clip the label to the widget's bounding box.
\li \p FL_ALIGN_WRAP - wrap the label text as needed.
\li \p FL_ALIGN_TEXT_OVER_IMAGE - show the label text over the image.
\li \p FL_ALIGN_IMAGE_OVER_TEXT - show the label image over the text (default).
\li \p FL_ALIGN_IMAGE_NEXT_TO_TEXT - The image will appear to the left of the text.
\li \p FL_ALIGN_TEXT_NEXT_TO_IMAGE - The image will appear to the right of the text.
\li \p FL_ALIGN_IMAGE_BACKDROP - The image will be used as a background for the widget.
</p>
<p>\anchor common_labeltype<br/>
\par labeltype()
</p>
<p>The \p labeltype() method sets the type of the label.  The
following standard label types are included:
</p>
<p>\li \p FL_NORMAL_LABEL - draws the text.
\li \p FL_NO_LABEL - does nothing.<br/>
\li \p FL_SHADOW_LABEL - draws a drop shadow under the text.
\li \p FL_ENGRAVED_LABEL - draws edges as though the text is engraved.
\li \p FL_EMBOSSED_LABEL - draws edges as thought the text is raised.
\li \p FL_ICON_LABEL - draws the icon associated with the text.
</p>
<p>\par image() and deimage()
</p>
<p>The \p image() and \p deimage() methods set an image that
will be displayed with the widget. The \p deimage() method sets the
image that is shown when the widget is inactive, while the \p image()
method sets the image that is shown when the widget is active.
</p>
<p>To make an image you use a subclass of<br/>
\ref ssect_Fl_Image "Fl_Image".
</p>
<p>\par Making Your Own Label Types
</p>
<p>Label types are actually indexes into a table of functions
that draw them. The primary purpose of this is to use this to
draw the labels in ways inaccessible through the
fl_font() mechanism (e.g. &lt;tt&gt;FL_ENGRAVED_LABEL&lt;/tt&gt;) or
with program-generated letters or symbology.
</p>
<p>\par Label Type Functions
</p>
<p>To setup your own label type you will need to write two
functions: one to draw and one to measure the label. The draw
function is called with a pointer to a Fl_Label
structure containing the label information, the bounding box for
the label, and the label alignment:
</p>
<p>\code<br/>
void xyz_draw(const Fl_Label *label, int x, int y, int w, int h, Fl_Align align) {
...<br/>
}<br/>
\endcode
</p>
<p>The label should be drawn \e inside this bounding box,
even if \p FL_ALIGN_INSIDE is not enabled. The function
is not called if the label value is \p NULL.
</p>
<p>The measure function is called with a pointer to a
Fl_Label structure and references to the width and
height:
</p>
<p>\code<br/>
void xyz_measure(const Fl_Label *label, int &amp;w, int &amp;h) {
...<br/>
}<br/>
\endcode
</p>
<p>The function should measure the size of the label and set
\p w and \p h to the size it will occupy.
</p>
<p>\par Adding Your Label Type
</p>
<p>The Fl::set_labeltype() method creates a label type
using your draw and measure functions:
</p>
<p>\code<br/>
#define XYZ_LABEL FL_FREE_LABELTYPE
</p>
<p>Fl::set_labeltype(XYZ_LABEL, xyz_draw, xyz_measure);
\endcode
</p>
<p>The label type number \p n can be any integer value
starting at the constant \p FL_FREE_LABELTYPE. Once you
have added the label type you can use the \p labeltype()
method to select your label type.
</p>
<p>The Fl::set_labeltype() method can also be used to overload
an existing label type such as \p FL_NORMAL_LABEL.
</p>
<p>\par Making your own symbols
</p>
<p>It is also possible to define your own drawings and add
them to the symbol list, so they can be rendered as part of
any label.
</p>
<p>To create a new symbol, you implement a drawing function 
&lt;tt&gt;void drawit(Fl_Color c)&lt;/tt&gt; which typically uses the
functions described in \ref ssect_Complex
to generate a vector shape inside a two-by-two units sized box
around the origin. This function is then linked into the symbols
table using fl_add_symbol():
</p>
<p>\code<br/>
int fl_add_symbol(const char <em>name, void (</em>drawit)(Fl_Color), int scalable)
\endcode
</p>
<p>\p name is the name of the symbol without the "@"; \p scalable
must be set to 1 if the symbol is generated using scalable vector drawing
functions.
</p>
<p>\code<br/>
int fl_draw_symbol(const char *name,int x,int y,int w,int h,Fl_Color col)
\endcode
</p>
<p>This function draws a named symbol fitting the given rectangle.
</p>
<p>\section common_callbacks Callbacks
</p>
<p>Callbacks are functions that are called when the value of a
widget changes. A callback function is sent a Fl_Widget
pointer of the widget that changed and a pointer to data that
you provide:
</p>
<p>\code<br/>
void xyz_callback(Fl_Widget *w, void *data) {
...<br/>
}<br/>
\endcode
</p>
<p>The \p callback() method sets the callback function for a
widget. You can optionally pass a pointer to some data needed for the
callback:
</p>
<p>\code<br/>
int xyz_data;
</p>
<p>button-&gt;callback(xyz_callback, &amp;xyz_data);
\endcode
</p>
<p>Normally callbacks are performed only when the value of the
widget changes. You can change this using the Fl_Widget::when()
method:
</p>
<p>\code<br/>
button-&gt;when(FL_WHEN_NEVER);<br/>
button-&gt;when(FL_WHEN_CHANGED);<br/>
button-&gt;when(FL_WHEN_RELEASE);<br/>
button-&gt;when(FL_WHEN_RELEASE_ALWAYS);<br/>
button-&gt;when(FL_WHEN_ENTER_KEY);<br/>
button-&gt;when(FL_WHEN_ENTER_KEY_ALWAYS);
button-&gt;when(FL_WHEN_CHANGED | FL_WHEN_NOT_CHANGED);
\endcode
</p>
<p>&lt;CENTER&gt;&lt;TABLE WIDTH="80%" BORDER="1" CELLPADDING="5" CELLSPACING="0" BGCOLOR="#cccccc"&gt;
&lt;TR&gt;
</p><p>        &lt;TD&gt;&lt;B&gt;Note:&lt;/B&gt;
</p>
<pre>
        You cannot delete a widget inside a callback, as the
        widget may still be accessed by FLTK after your callback
        is completed. Instead, use the Fl::delete_widget()
        method to mark your widget for deletion when it is safe
        to do so.

        &lt;B&gt;Hint:&lt;/B&gt;

        Many programmers new to FLTK or C++ try to use a
        non-static class method instead of a static class method
        or function for their callback. Since callbacks are done
        outside a C++ class, the &lt;tt&gt;this&lt;/tt&gt; pointer is not
        initialized for class methods.

        To work around this problem, define a static method
        in your class that accepts a pointer to the class, and
        then have the static method call the class method(s) as
        needed. The data pointer you provide to the
        \p callback() method of the widget can be a
        pointer to the instance of your class.
</pre>
<p>\code<br/>
class Foo {<br/>
  void my_callback(Fl_Widget *w);<br/>
  static void my_static_callback(Fl_Widget *w, void *f) { ((Foo *)f)-&gt;my_callback(w); }
  ...<br/>
}
</p>
<p>...
</p>
<p>w-&gt;callback(my_static_callback, (void *)this);
\endcode
</p><p>        &lt;/TD&gt;<br/>
&lt;/TR&gt;<br/>
&lt;/TABLE&gt;&lt;/CENTER&gt;
</p>
<p>\section common_shortcuts Shortcuts
</p>
<p>Shortcuts are key sequences that activate widgets such as
buttons or menu items. The \p shortcut() method sets the
shortcut for a widget:
</p>
<p>\code<br/>
button-&gt;shortcut(FL_Enter);<br/>
button-&gt;shortcut(FL_SHIFT + 'b');<br/>
button-&gt;shortcut(FL_CTRL + 'b');<br/>
button-&gt;shortcut(FL_ALT + 'b');<br/>
button-&gt;shortcut(FL_CTRL + FL_ALT + 'b');
button-&gt;shortcut(0); // no shortcut<br/>
\endcode
</p>
<p>The shortcut value is the key event value - the ASCII value
or one of the special keys described in
\ref enumerations_event_key<br/>
combined with any modifiers like \p Shift , \p Alt , and \p Control.
</p>
<p>\htmlonly<br/>
&lt;hr&gt;<br/>
&lt;table summary="navigation bar" width="100%" border="0"&gt;
&lt;tr&gt;<br/>
  &lt;td width="45%" align="LEFT"&gt;<br/>
    &lt;a class="el" href="basics.html"&gt;<br/>
    [Prev]<br/>
    FLTK Basics<br/>
    &lt;/a&gt;<br/>
  &lt;/td&gt;<br/>
  &lt;td width="10%" align="CENTER"&gt;<br/>
    &lt;a class="el" href="index.html"&gt;[Index]&lt;/a&gt;
  &lt;/td&gt;<br/>
  &lt;td width="45%" align="RIGHT"&gt;<br/>
    &lt;a class="el" href="editor.html"&gt;<br/>
    Designing a Simple Text Editor<br/>
    [Next]<br/>
    &lt;/a&gt;<br/>
  &lt;/td&gt;<br/>
&lt;/tr&gt;<br/>
&lt;/table&gt;<br/>
\endhtmlonly
</p>
<p>*/</p>

</body>
</html>
